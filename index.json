[{"categories":null,"contents":"I presented this webinar on February 12th, 2025, as a part of a series of weekly Compute Ontario Colloquia. This is a series of talks about using modern C++ for high-performance data science. In the first talk of the series, we talk a little bit about the pros and cons of using C++ for data science projects and then we cover Xeus-Cling and G3P for rapid-prototyping of C++ codes and embedding plots and charts in a Jupyter notebook, respectively. The whole series will be available as an executable book at https://armin.sobhani.me/high-performance-data-science-with-modern-cpp .\n","date":"February 14, 2025","hero":"/posts/videos/data_science_cpp/images/PXL_20240413_200806002.jpg","permalink":"https://armin.sobhani.me/posts/videos/data_science_cpp/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-february-12th-2025-as-a-part-of-a-series-of-weekly-compute-ontario-colloquiahttpswwwcomputeontariocatraining-colloquia\"\u003eI presented this webinar on February 12th, 2025, as a part of a series of weekly \u003ca href=\"https://www.computeontario.ca/training-colloquia\" target=\"_blank\" rel=\"noopener\"\u003eCompute Ontario Colloquia\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/YPQUIkSIFhw?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eThis is a series of talks about using modern \u003ccode\u003eC++\u003c/code\u003e for high-performance data science. In the first talk of the series, we talk a little bit about the pros and cons of using \u003ccode\u003eC++\u003c/code\u003e for data science projects and then we cover \u003ca href=\"https://github.com/jupyter-xeus/xeus-cling\" target=\"_blank\" rel=\"noopener\"\u003eXeus-Cling\u003c/a\u003e and \u003ca href=\"https://github.com/arminms/g3p\" target=\"_blank\" rel=\"noopener\"\u003eG3P\u003c/a\u003e for rapid-prototyping of \u003ccode\u003eC++\u003c/code\u003e codes and embedding plots and charts in a Jupyter notebook, respectively. The whole series will be available as an \u003ca href=\"https://executablebooks.org/\" target=\"_blank\" rel=\"noopener\"\u003eexecutable book\u003c/a\u003e at \u003ca href=\"https://armin.sobhani.me/high-performance-data-science-with-modern-cpp\" target=\"_blank\" rel=\"noopener\"\u003ehttps://armin.sobhani.me/high-performance-data-science-with-modern-cpp\u003c/a\u003e .\u003c/p\u003e","tags":null,"title":"High-Performance Data Science with Modern C++: Xeus-Cling and G3P"},{"categories":null,"contents":"I presented this webinar on August 7th, 2024, as a part of a series of weekly Compute Ontario Colloquia. Developed collaboratively by major browser vendors, including Mozilla, Google, Microsoft, and Apple, WebAssembly (Wasm) addresses the limitations of traditional web programming languages like JavaScript. But what makes it so compelling for scientists? First, Wasm allows code written in languages like C/C++, Fortran or Rust to be compiled into its instruction format and run directly in the browser, making it accessible to anyone without installation hassles and eliminating the need for external servers. Second, with Wasm, developers can recycle existing code with near-native performance but without the hassle of rewriting it in JavaScript. Join us as we explore how Wasm is reshaping scientific workflows and empowering researchers worldwide.\n","date":"September 20, 2024","hero":"/posts/videos/gol2p/images/PXL_20240901_113740870.jpg","permalink":"https://armin.sobhani.me/posts/videos/gol2p/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-august-7th-2024-as-a-part-of-a-series-of-weekly-compute-ontario-colloquiahttpswwwcomputeontariocatraining-colloquia\"\u003eI presented this webinar on August 7th, 2024, as a part of a series of weekly \u003ca href=\"https://www.computeontario.ca/training-colloquia\" target=\"_blank\" rel=\"noopener\"\u003eCompute Ontario Colloquia\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/c4MZPuLog28?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eDeveloped collaboratively by major browser vendors, including Mozilla, Google, Microsoft, and Apple, WebAssembly (Wasm) addresses the limitations of traditional web programming languages like JavaScript. But what makes it so compelling for scientists? First, Wasm allows code written in languages like C/C++, Fortran or Rust to be compiled into its instruction format and run directly in the browser, making it accessible to anyone without installation hassles and eliminating the need for external servers. Second, with Wasm, developers can recycle existing code with near-native performance but without the hassle of rewriting it in JavaScript. Join us as we explore how Wasm is reshaping scientific workflows and empowering researchers worldwide.\u003c/p\u003e","tags":null,"title":"The Emergence of WebAssembly (Wasm) in Scientific Computing"},{"categories":null,"contents":"I presented this webinar on October 18th, 2023, as a part of a series of weekly Compute Ontario Colloquia. p2rng (https://github.com/arminms/p2rng) is a modern header-only C++ library for parallel algorithmic (pseudo) random number generation supporting OpenMP, CUDA, ROCm and oneAPI. Playing fair, mostly required for debugging and unit testing, is one of the unique features of p2rng. That means using the same seed and distribution you always get the same sequence of random numbers on all supported platforms. p2rng provides parallel versions of STL’s std::generate() and std::generate_n() algorithms with the same interface. In this seminar we first start with a quick review of preliminary concepts about algorithmic random number generators in general and parallelization techniques in particular. Then we continue with the standard way of generating random numbers with STL algorithms and how we can turn them into parallel version using p2rng.\n","date":"October 23, 2023","hero":"/posts/videos/p2rng/images/PXL_20220718_233206312.jpg","permalink":"https://armin.sobhani.me/posts/videos/p2rng/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-october-18th-2023-as-a-part-of-a-series-of-weekly-compute-ontario-colloquiahttpswwwcomputeontariocatraining-colloquia\"\u003eI presented this webinar on October 18th, 2023, as a part of a series of weekly \u003ca href=\"https://www.computeontario.ca/training-colloquia\" target=\"_blank\" rel=\"noopener\"\u003eCompute Ontario Colloquia\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/nyOH8nvHBss?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003e\u003ccode\u003ep2rng\u003c/code\u003e (\u003ca href=\"https://github.com/arminms/p2rng\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/arminms/p2rng\u003c/a\u003e) is a modern header-only C++ library for parallel algorithmic (pseudo) random number generation supporting \u003ca href=\"https://www.openmp.org/\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003eOpenMP\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://developer.nvidia.com/cuda-zone\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003eCUDA\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://www.amd.com/en/graphics/servers-solutions-rocm\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003eROCm\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://www.intel.com/content/www/us/en/developer/tools/oneapi/overview.html\" target=\"_blank\" rel=\"noopener\"\u003e\u003ccode\u003eoneAPI\u003c/code\u003e\u003c/a\u003e. Playing fair, mostly required for debugging and unit testing, is one of the unique features of \u003ccode\u003ep2rng\u003c/code\u003e. That means using the same seed and distribution you always get the same sequence of random numbers on all supported platforms. \u003ccode\u003ep2rng\u003c/code\u003e provides parallel versions of \u003cem\u003eSTL\u003c/em\u003e’s \u003ccode\u003estd::generate()\u003c/code\u003e and \u003ccode\u003estd::generate_n()\u003c/code\u003e algorithms with the same interface.\nIn this seminar we first start with a quick review of preliminary concepts about algorithmic random number generators in general and parallelization techniques in particular. Then we continue with the standard way of generating random numbers with \u003cem\u003eSTL\u003c/em\u003e algorithms and how we can turn them into parallel version using \u003ccode\u003ep2rng\u003c/code\u003e.\u003c/p\u003e","tags":null,"title":"p2rng – A C++ Parallel Random Number Generator Library for the Masses"},{"categories":null,"contents":"I presented this webinar on April 19th, 2023, as a part of a series of weekly Compute Ontario Colloquia. For a long time, CUDA was the platform of choice for developing applications running on NVIDIA’s GPUs. That is starting to change in recent years with the introduction of AMD’s ROCm and Intel’s oneAPI which both support GPUs by other vendors. While ROCm targets both AMD and NVIDIA GPUs, using the recently released drivers by CodePlay, oneAPI applications can run on NVIDIA and AMD in addition to Intel’s GPUs. The question this seminar is trying to answer is if in 2023 you want to start a project targeting GPUs, what would be your platform of choice? Should you go with one or all of them? Later in the seminar, a boilerplate framework named one4all will be introduced that streamlines the process of developing applications targeting all the above platforms. Unit testing with Catch2 as well as benchmarking with Google benchmark are already supported by the framework.\n","date":"April 21, 2023","hero":"/posts/videos/one4all/images/p1030224.jpg","permalink":"https://armin.sobhani.me/posts/videos/one4all/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-april-19th-2023-as-a-part-of-a-series-of-weekly-compute-ontario-colloquiahttpswwwcomputeontariocatraining-colloquia\"\u003eI presented this webinar on April 19th, 2023, as a part of a series of weekly \u003ca href=\"https://www.computeontario.ca/training-colloquia\" target=\"_blank\" rel=\"noopener\"\u003eCompute Ontario Colloquia\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/RYtdiOhrv0Q?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eFor a long time, CUDA was the platform of choice for developing applications running on NVIDIA’s GPUs. That is starting to change in recent years with the introduction of AMD’s ROCm and Intel’s oneAPI which both support GPUs by other vendors. While ROCm targets both AMD and NVIDIA GPUs, using the recently released drivers by CodePlay, oneAPI applications can run on NVIDIA and AMD in addition to Intel’s GPUs. The question this seminar is trying to answer is if in 2023 you want to start a project targeting GPUs, what would be your platform of choice? Should you go with one or all of them? Later in the seminar, a boilerplate framework named \u003ca href=\"https://github.com/arminms/one4all\" target=\"_blank\" rel=\"noopener\"\u003eone4all\u003c/a\u003e will be introduced that streamlines the process of developing applications targeting all the above platforms. Unit testing with Catch2 as well as benchmarking with Google benchmark are already supported by the framework.\u003c/p\u003e","tags":null,"title":"CUDA, ROCm, oneAPI – All for One or One for All?"},{"categories":null,"contents":"Lately, I\u0026rsquo;ve been noticing there are more and more black strands among my now almost completely grey hair. I never asked anyone else\u0026rsquo;s opinion about it simply because my impression was that\u0026rsquo;s just my imagination. That all changed yesterday\u0026hellip;\nYesterday, in my monthly routine haircut, as soon as my barber who is a very sharp (mentally and instrumentally) Asian lady started to trim my hair, completely to my surprise, asked me if I have noticed my hair is backing to black cause she can tell for sure it is! 😲\nI said “As a matter of fact, yes…” but before I could even finish she continued by saying it’s happening to about 10-15 of her regular customers!!! 🤯 She genuinely believed it’s one of the side effects of covid vaccine.\nTrue or false, that’s an interesting observation. Have you had such an experience with your hair color recently?\nWhether it’s something that happens to people with certain ethnicity or traits and if it’s gonna last, are among many questions that remained to be answered as the time goes by.\nTop image: Barber cutting hair with comb by shixart1985\n","date":"March 27, 2023","hero":"/posts/random/back_to_black/images/48968346138_c788441364_k.jpg","permalink":"https://armin.sobhani.me/posts/random/back_to_black/","summary":"\u003cp\u003eLately, I\u0026rsquo;ve been noticing there are more and more black strands among my now almost completely grey hair. I never asked anyone else\u0026rsquo;s opinion about it simply because my impression was that\u0026rsquo;s just my imagination. That all changed yesterday\u0026hellip;\u003c/p\u003e\n\u003cp\u003eYesterday, in my monthly routine haircut, as soon as my barber who is a very sharp (mentally and instrumentally) Asian lady started to trim my hair, completely to my surprise, asked me if I have noticed my hair is backing to black cause she can tell for sure it is! 😲\u003c/p\u003e","tags":null,"title":"Back to Black"},{"categories":null,"contents":"I presented this webinar on September 7th, 2022 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. Visual Studio Code (VSCode) is a free and open-source code editor developed by Microsoft for Windows, Linux, and macOS. It includes support for debugging, embedded Git version control, syntax highlighting, intelligent code completion, snippets, and code refactoring. In Part I of this seminar we covered configuring SSH agent and config file, version controlling with external repositories, providing makefile and CMake support and remote debugging on compute nodes using the proxy jump method:\nRemote Development on Clusters with VSCode - Part I In Part II, we will continue with remote debugging using the SSH tunneling method and remote debugging CUDA codes using NSight VSCode extension.\nThe materials presented during the live session are available on SHARCNET GitHub account.\n","date":"September 7, 2022","hero":"/posts/videos/vscode_remote_2/images/p1000129.jpg","permalink":"https://armin.sobhani.me/posts/videos/vscode_remote_2/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-september-7th-2022-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on September 7th, 2022 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/CsgBGpampvc?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eVisual Studio Code (VSCode) is a free and open-source code editor developed by Microsoft for Windows, Linux, and macOS. It includes support for debugging, embedded Git version control, syntax highlighting, intelligent code completion, snippets, and code refactoring. In Part I of this seminar we covered configuring SSH agent and config file, version controlling with external repositories, providing makefile and CMake support and remote debugging on compute nodes using the proxy jump method:\u003c/p\u003e","tags":null,"title":"Remote Development on Clusters with VSCode - Part II"},{"categories":null,"contents":"I presented this webinar on January 12th, 2022 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. Visual Studio Code (VSCode) is a free and open-source code editor developed by Microsoft for Windows, Linux, and macOS. It includes support for debugging, embedded Git version control, syntax highlighting, intelligent code completion, snippets, and code refactoring. It is also extensible and customizable, so users can install extensions to add new languages, themes, debuggers and change the editor\u0026rsquo;s keyboard shortcuts, and preferences.\nIn this webinar we will focus on how to do remote development on HPC clusters effectively. Including but not limited to configuring SSH agent and config file, version controlling with external repositories, providing makefile and CMake support, remote debugging on compute nodes, etc. The materials presented during the live session are available on SHARCNET GitHub account.\nRemote Development on Clusters with VSCode - Part II ","date":"January 12, 2022","hero":"/posts/videos/vscode_remote_1/images/p1000134.jpg","permalink":"https://armin.sobhani.me/posts/videos/vscode_remote_1/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-january-12th-2022-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on January 12th, 2022 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/u9k6HikDyqk?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eVisual Studio Code (VSCode) is a free and open-source code editor developed by Microsoft for Windows, Linux, and macOS. It includes support for debugging, embedded Git version control, syntax highlighting, intelligent code completion, snippets, and code refactoring. It is also extensible and customizable, so users can install extensions to add new languages, themes, debuggers and change the editor\u0026rsquo;s keyboard shortcuts, and preferences.\u003c/p\u003e","tags":null,"title":"Remote Development on Clusters with VSCode - Part I"},{"categories":null,"contents":"I presented this webinar on March 17, 2021 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. In a multithreaded C/C++ program, using standard non-threaded allocators, memory allocation can become a bottleneck. That is firstly caused by thread competition for a lock on a shared global heap, and secondly for caching effects. Programs that run this way are not scalable and may slow down as the number of cores increases. Scalable memory allocators such as Intel’s TBB allocators, FreeBSD’s jemalloc and Google’s TCMalloc solve this problem by providing various optimizations such as per-CPU caches, thread-private heaps, sized deletes and fast/slow path improvements. You can easily gain a 20-30% performance improvement for parallel sections and even 4X in extreme cases by simply relinking with a scalable memory allocator. This webinar will tell you all about these allocators, with a live session running some benchmarks at the end. Materials presented during the live session are available on GitHub.\n","date":"March 17, 2021","hero":"/posts/videos/sma/images/p1000123.jpg","permalink":"https://armin.sobhani.me/posts/videos/sma/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-march-17-2021-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on March 17, 2021 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/1UGwixrLQGU?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eIn a multithreaded C/C++ program, using standard non-threaded allocators, memory allocation can become a bottleneck. That is firstly caused by thread competition for a lock on a shared global heap, and secondly for caching effects. Programs that run this way are not scalable and may slow down as the number of cores increases. Scalable memory allocators such as Intel’s TBB allocators, FreeBSD’s jemalloc and Google’s TCMalloc solve this problem by providing various optimizations such as per-CPU caches, thread-private heaps, sized deletes and fast/slow path improvements. You can easily gain a 20-30% performance improvement for parallel sections and even 4X in extreme cases by simply relinking with a scalable memory allocator. This webinar will tell you all about these allocators, with a live session running some benchmarks at the end. Materials presented during the live session are available on \u003ca href=\"https://github.com/arminms/scalable_allocators\" target=\"_blank\" rel=\"noopener\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e","tags":null,"title":"Scalable Memory Allocation for Parallel Algorithms"},{"categories":null,"contents":"I presented this webinar on July 29th, 2020 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. Last year and earlier this year, SHARCNET presented two webinars introducing C++17 parallel algorithms (first webinar; second webinar). There was an interesting frequently asked question: is it possible to use them in an MPI setup? This seminar tries to address that question. First, there will be a very short intro to C++17 parallel algorithms followed by an overview of Partitioned Global Address Space (PGAS) parallel programming model. Then, DASH C++ template library will be introduced. A live demonstration of installing and building programs with DASH concludes the webinar. You can find material presented during the live session on GitHub.\n","date":"July 29, 2020","hero":"/posts/videos/pgas/images/p1010380.jpg","permalink":"https://armin.sobhani.me/posts/videos/pgas/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-july-29th-2020-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on July 29th, 2020 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/H1LGxHN7Bqk?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eLast year and earlier this year, SHARCNET presented two webinars introducing C++17 parallel algorithms\n(\u003ca href=\"https://youtu.be/BQpp8SaIrgE\" target=\"_blank\" rel=\"noopener\"\u003efirst webinar\u003c/a\u003e; \u003ca href=\"https://youtu.be/yU645WpDcuM\" target=\"_blank\" rel=\"noopener\"\u003esecond webinar\u003c/a\u003e).\nThere was an interesting frequently asked question: is it possible to use them in an MPI setup? This seminar tries to address that question. First, there will be a very short intro to C++17 parallel algorithms followed by an overview of Partitioned Global Address Space (PGAS) parallel programming model. Then, \u003ca href=\"http://www.dash-project.org/\" target=\"_blank\" rel=\"noopener\"\u003eDASH C++ template library\u003c/a\u003e will be introduced. A live demonstration of installing and building programs with DASH concludes the webinar. You can find material presented during the live session on \u003ca href=\"https://github.com/arminms/dash-tutorial\" target=\"_blank\" rel=\"noopener\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e","tags":null,"title":"How to Use C++ Parallel Algorithms in a Distributed Memory Setup (i.e. MPI)"},{"categories":null,"contents":"I presented this webinar on February 27th, 2019 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. If you are programming or have already developed with C++, there is a good chance that you have used Standard Template Library (STL) containers and algorithms in your codes. In that case, you can easily boost the performance of your existing codes with parallel algorithms introduced in C++17. The good news is you do not have to wait until the support for the parallel algorithm is added to the C++ compiler of your choice. The Intel’s Parallel STL is a fairly complete implementation of the C++ standard library algorithms with support for execution policies, as specified in ISO/IEC 14882:2017 standard, AKA C++17. It is a standalone header-only library available for free on GitHub (https://github.com/intel/parallelstl). It can work with any C++11 compiler that works with Intel’s Threading Building Blocks (TBB), which is also available for free at https://www.threadingbuildingblocks.org/. In addition, if you want to use non-standard vectorization (unsequenced policies), your compiler should support OpenMP 4.0 SIMD constructs. Intel have offered to donate their implementation to both GCC and Clang.\nThis talk gives an overview of the C++17 execution policies, demonstrates how to use the Intel’s Parallel STL library on SHARCNET’s Graham cluster, and concludes with some benchmark results.\nCode examples: https://git.sharcnet.ca/asobhani/parallelstl_tutorial\n","date":"February 27, 2019","hero":"/posts/videos/parallel_stl/images/p1010379.jpg","permalink":"https://armin.sobhani.me/posts/videos/parallel_stl/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-february-27th-2019-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on February 27th, 2019 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/yU645WpDcuM?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eIf you are programming or have already developed with C++, there is a good chance that you have used Standard Template Library (STL) containers and algorithms in your codes. In that case, you can easily boost the performance of your existing codes with parallel algorithms introduced in C++17. The good news is you do not have to wait until the support for the parallel algorithm is added to the C++ compiler of your choice. The Intel’s Parallel STL is a fairly complete implementation of the C++ standard library algorithms with support for execution policies, as specified in ISO/IEC 14882:2017 standard, AKA C++17. It is a standalone header-only library available for free on GitHub (\u003ca href=\"https://github.com/intel/parallelstl%29\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/intel/parallelstl)\u003c/a\u003e. It can work with any C++11 compiler that works with Intel’s Threading Building Blocks (TBB), which is also available for free at \u003ca href=\"https://www.threadingbuildingblocks.org/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.threadingbuildingblocks.org/\u003c/a\u003e. In addition, if you want to use non-standard vectorization (unsequenced policies), your compiler should support OpenMP 4.0 SIMD constructs. Intel have offered to donate their implementation to both GCC and Clang.\u003c/p\u003e","tags":null,"title":"Dipping into C++17 Parallel Algorithms with Intel's Parallel STL"},{"categories":null,"contents":"I presented this webinar on August 15th, 2018 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. The Boost Compute library provides a C++ interface to multi-core CPU and GPGPU computing platforms based on OpenCL. It provides a high-level, STL-like API and is portable to a wide variety of parallel accelerators including GPUs, FPGAs, and multi-core CPUs. This seminar gives an overview of the library and demonstrates how to write and execute high-performance C++ applications on SHARCNET clusters.\n","date":"August 15, 2018","hero":"/posts/videos/boost_compute/images/p1010364.jpg","permalink":"https://armin.sobhani.me/posts/videos/boost_compute/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-august-15th-2018-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on August 15th, 2018 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/OWzCJn7WMKI?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eThe Boost Compute library provides a C++ interface to multi-core CPU and GPGPU computing platforms based on OpenCL. It provides a high-level, STL-like API and is portable to a wide variety of parallel accelerators including GPUs, FPGAs, and multi-core CPUs. This seminar gives an overview of the library and demonstrates how to write and execute high-performance C++ applications on SHARCNET clusters.\u003c/p\u003e","tags":null,"title":"Harnessing the Power of Heterogeneous Computing using Boost.Compute + OpenCL"},{"categories":null,"contents":"I presented this webinar on February 28th, 2018 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. Visual Studio Code (vscode) is a free and open-source code editor developed by Microsoft for Windows, Linux, and macOS. It includes support for debugging, embedded Git version control, syntax highlighting, intelligent code completion, snippets, and code refactoring. It is also extensible and customizable, so users can install extensions to add new languages, themes, debuggers and change the editor’s keyboard shortcuts, and preferences.\nIn this seminar we focus on one compiled and one scripting language common in advanced research computing projects, namely C/C++ and Python, respectively. We show how to use the same CMake configuration we have developed in the previous talk to edit, version-control, build and debug our C/C++ codebase exactly the same way in vscode on different platforms (only Linux and Windows will be demonstrated). Then we show how to deal effectively with Python codes.\nSome knowledge of Git version control system, CMake build system, and Nix package manager is desirable but not mandatory. To that end, reviewing the following previous seminars before attending this one may be helpful:\nGit and SHARCNET Automating Software Build Process using CMake – Part I Automating Software Build Process using CMake – Part II Exploring a new approach to package management ","date":"February 28, 2018","hero":"/posts/videos/vscode_1/images/p1010356.jpg","permalink":"https://armin.sobhani.me/posts/videos/vscode_1/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-february-28th-2018-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on February 28th, 2018 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/aR2L-UVmNXA?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eVisual Studio Code (vscode) is a free and open-source code editor developed by Microsoft for Windows, Linux, and macOS. It includes support for debugging, embedded Git version control, syntax highlighting, intelligent code completion, snippets, and code refactoring. It is also extensible and customizable, so users can install extensions to add new languages, themes, debuggers and change the editor’s keyboard shortcuts, and preferences.\u003c/p\u003e","tags":null,"title":"Visual Studio Code – Your Next Coding Companion for Advanced Research Computing"},{"categories":null,"contents":"I presented this webinar on April 26th, 2017 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. CMake is a cross-platform, free and open-source build system that allows you automatically build, test, verify, package and deploy software in a compiler-independent manner. In Part I of this seminar we introduced CMake and the first three steps of our tutorial:\nAutomating Software Build Process using CMake – Part I In Part II we will continue with more steps covering other techniques like adding options, correct way of finding Boost library, configuring header files, producing installation packages and so on. It is highly recommended to review the prior talk before attending this one.\n","date":"April 26, 2017","hero":"/posts/videos/cmake_2/images/p1010137.jpg","permalink":"https://armin.sobhani.me/posts/videos/cmake_2/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-april-26th-2017-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on April 26th, 2017 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/Tsd6bAW8uLg?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eCMake is a cross-platform, free and open-source build system that allows you automatically build, test, verify, package and deploy software in a compiler-independent manner. In Part I of this seminar we introduced CMake and the first three steps of our tutorial:\u003c/p\u003e","tags":null,"title":"Automating Software Build Process using CMake - Part II"},{"categories":null,"contents":"I presented this webinar on September 14, 2016 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. CMake is a cross-platform, free and open-source build system that allows you automatically build, test, verify, package and deploy software in a compiler-independent manner. CMake was originally created in 1999 for the Insight Toolkit (ITK) funded by the US National Library of Medicine (NLM) as part of the Visible Human Project and over the past 17 years has become the most popular build tool for C/C++ especially in the field of scientific research (e.g. medical computing, visualization, computer vision and HPC). Some notable applications that use CMake for their build process are: Qt, MySQL, Gromacs, Blender, OpenCV, VTK and ParaView.\nCMake is designed to be used in conjunction with native build environments such as Unix Makefiles, Microsoft Visual Studio and Apple’s Xcode. The build process is controlled by creating one or more configuration files (called CMakeLists.txt files) in each source directory (including subdirectories) that make up a project. Each CMakeLists.txt consists of one or more commands. One of the key features of CMake is the ability to build a directory tree outside the source tree, hence, in case the build directory is removed, the source files remain unaffected. CMake can generate makefiles for many platforms and IDEs including Unix, Windows, Mac OS X, OS/2, MSVC, Unix Makefiles, Ninja, Cygwin, MinGW, NMake, Xcode, CodeBlocks, CodeLite, Eclipse CDT and even Sublime Text.\nThis talk will introduce CMake and go over the basics of using CMake on both user computers and SHARCNET systems to configure and build software. Basic steps of developing a working CMakeLists.txt for a sample software project will also be covered. Some programming experience is helpful but not mandatory.\n","date":"September 14, 2016","hero":"/posts/videos/cmake_1/images/p1010039.jpg","permalink":"https://armin.sobhani.me/posts/videos/cmake_1/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-september-14-2016-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on September 14, 2016 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/7wxzoAdZcKE?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eCMake is a cross-platform, free and open-source build system that allows you automatically build, test, verify, package and deploy software in a compiler-independent manner. CMake was originally created in 1999 for the Insight Toolkit (ITK) funded by the US National Library of Medicine (NLM) as part of the Visible Human Project and over the past 17 years has become the most popular build tool for C/C++ especially in the field of scientific research (e.g. medical computing, visualization, computer vision and HPC). Some notable applications that use CMake for their build process are: Qt, MySQL, Gromacs, Blender, OpenCV, VTK and ParaView.\u003c/p\u003e","tags":null,"title":"Automating Software Build Process using CMake - Part I"},{"categories":null,"contents":"I presented this webinar on June 24th, 2015 as a part of a series of regular biweekly General Interest Webinars ran by SHARCNET. If you need to expose a new HPC service or a brand new scientific methodology to outside community by developing a highly interactive web application but without gaining familiarity with ever-changing technologies such as HTML/XHTML, JavaScript, CSS, AJAX, CGI, DHTML, SVG/VML/Canvas, PHP, etc., this webinar is for you. Wt (pronounced \u0026lsquo;witty\u0026rsquo;) is a freely available (http://www.webtoolkit.eu/) widget-centric C++ library and application server for developing web applications that brings the desktop programming model to web application development. From a programmer\u0026rsquo;s perspective, the Wt API is similar to those offered by libraries such as Qt, GTK, wxWindows, and the like. However, instead of rendering widgets to Windows/X11 windows, Wt incrementally renders the widgets in web browsers. A web application developed with Wt is written in only one compiled language (C++), from which the library generates the necessary HTML/XHTML, JavaScript, CGI, or AJAX code. If available, Wt will maximally use JavaScript and AJAX, but applications developed using Wt will also function correctly when AJAX is not available, or when JavaScript is disabled, reverting to a plain HTML/CGI mechanism for communication between browser and server. Browser-side events such as button clicks, mouse movements, and drag-and-drop events are transparently converted into server-side events using Wt\u0026rsquo;s signal/slot mechanism. Being a native C++ library, web applications developed with Wt typically enjoy greater efficiency and a smaller footprint than Java or Ruby solutions. As such, Wt lends itself to devices where efficiency and footprint matters, like in embedded applications.\nIn this webinar, I will introduce Wt, demonstrate some interesting samples and go over the basics of making an interactive web application. The audience are expected to have some basic programming skills preferably in C++, but no experience in HTML, CSS or JavaScript is necessary.\n","date":"June 24, 2015","hero":"/posts/videos/wt/images/p1010038.jpg","permalink":"https://armin.sobhani.me/posts/videos/wt/","summary":"\u003ch4 id=\"i-presented-this-webinar-on-june-24th-2015-as-a-part-of-a-series-of-regular-biweekly-general-interest-webinars-ran-by-sharcnethttpssharcnetca\"\u003eI presented this webinar on June 24th, 2015 as a part of a series of regular biweekly General Interest Webinars ran by \u003ca href=\"https://sharcnet.ca\" target=\"_blank\" rel=\"noopener\"\u003eSHARCNET\u003c/a\u003e.\u003c/h4\u003e\n\u003chr\u003e\n\u003cdiv style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"\u003e\n      \u003ciframe allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"allowfullscreen\" loading=\"eager\" referrerpolicy=\"strict-origin-when-cross-origin\" src=\"https://www.youtube.com/embed/qDc_s8hy3cY?autoplay=0\u0026amp;controls=1\u0026amp;end=0\u0026amp;loop=0\u0026amp;mute=0\u0026amp;start=0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" title=\"YouTube video\"\u003e\u003c/iframe\u003e\n    \u003c/div\u003e\n\n\u003chr\u003e\n\u003cp\u003eIf you need to expose a new HPC service or a brand new scientific methodology to outside community by developing a highly interactive web application but without gaining familiarity with ever-changing technologies such as HTML/XHTML, JavaScript, CSS, AJAX, CGI, DHTML, SVG/VML/Canvas, PHP, etc., this webinar is for you. Wt (pronounced \u0026lsquo;witty\u0026rsquo;) is a freely available (\u003ca href=\"http://www.webtoolkit.eu/\" target=\"_blank\" rel=\"noopener\"\u003ehttp://www.webtoolkit.eu/\u003c/a\u003e) widget-centric C++ library and application server for developing web applications that brings the desktop programming model to web application development. From a programmer\u0026rsquo;s perspective, the Wt API is similar to those offered by libraries such as Qt, GTK, wxWindows, and the like. However, instead of rendering widgets to Windows/X11 windows, Wt incrementally renders the widgets in web browsers. A web application developed with Wt is written in only one compiled language (C++), from which the library generates the necessary HTML/XHTML, JavaScript, CGI, or AJAX code. If available, Wt will maximally use JavaScript and AJAX, but applications developed using Wt will also function correctly when AJAX is not available, or when JavaScript is disabled, reverting to a plain HTML/CGI mechanism for communication between browser and server. Browser-side events such as button clicks, mouse movements, and drag-and-drop events are transparently converted into server-side events using Wt\u0026rsquo;s signal/slot mechanism. Being a native C++ library, web applications developed with Wt typically enjoy greater efficiency and a smaller footprint than Java or Ruby solutions. As such, Wt lends itself to devices where efficiency and footprint matters, like in embedded applications.\u003c/p\u003e","tags":null,"title":"Programming with Wt - A C++ library for developing stateful and highly interactive web applications"}]