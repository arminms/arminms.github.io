[{"categories":null,"contents":"This webinar was presented by me on February 27th, 2019 as a part of a series of regular biweekly webinars ran by SHARCNET. If you are programming or have already developed with C++, there is a good chance that you have used Standard Template Library (STL) containers and algorithms in your codes. In that case, you can easily boost the performance of your existing codes with parallel algorithms introduced in C++17. The good news is you do not have to wait until the support for the parallel algorithm is added to the C++ compiler of your choice. The Intel’s Parallel STL is a fairly complete implementation of the C++ standard library algorithms with support for execution policies, as specified in ISO/IEC 14882:2017 standard, AKA C++17. It is a standalone header-only library available for free on GitHub (https://github.com/intel/parallelstl). It can work with any C++11 compiler that works with Intel’s Threading Building Blocks (TBB), which is also available for free at https://www.threadingbuildingblocks.org/. In addition, if you want to use non-standard vectorization (unsequenced policies), your compiler should support OpenMP 4.0 SIMD constructs. Intel have offered to donate their implementation to both GCC and Clang.\nThis talk gives an overview of the C++17 execution policies, demonstrates how to use the Intel’s Parallel STL library on SHARCNET’s Graham cluster, and concludes with some benchmark results.\nCode examples: https://git.sharcnet.ca/asobhani/parallelstl_tutorial\n","date":"February 27, 2019","hero":"/posts/videos/parallel_stl/images/p1010379.jpg","permalink":"https://arminms.github.io/posts/videos/parallel_stl/","summary":"This webinar was presented by me on February 27th, 2019 as a part of a series of regular biweekly webinars ran by SHARCNET. If you are programming or have already developed with C++, there is a good chance that you have used Standard Template Library (STL) containers and algorithms in your codes. In that case, you can easily boost the performance of your existing codes with parallel algorithms introduced in C++17.","tags":null,"title":"Dipping into C++17 Parallel Algorithms with Intel's Parallel STL"},{"categories":null,"contents":"This webinar was presented by me on August 15th, 2018 as a part of a series of regular biweekly webinars ran by SHARCNET. The Boost Compute library provides a C++ interface to multi-core CPU and GPGPU computing platforms based on OpenCL. It provides a high-level, STL-like API and is portable to a wide variety of parallel accelerators including GPUs, FPGAs, and multi-core CPUs. This seminar gives an overview of the library and demonstrates how to write and execute high-performance C++ applications on SHARCNET clusters.\n","date":"August 15, 2018","hero":"/posts/videos/boost_compute/images/p1010364.jpg","permalink":"https://arminms.github.io/posts/videos/boost_compute/","summary":"This webinar was presented by me on August 15th, 2018 as a part of a series of regular biweekly webinars ran by SHARCNET. The Boost Compute library provides a C++ interface to multi-core CPU and GPGPU computing platforms based on OpenCL. It provides a high-level, STL-like API and is portable to a wide variety of parallel accelerators including GPUs, FPGAs, and multi-core CPUs. This seminar gives an overview of the library and demonstrates how to write and execute high-performance C++ applications on SHARCNET clusters.","tags":null,"title":"Harnessing the Power of Heterogeneous Computing using Boost.Compute + OpenCL"},{"categories":null,"contents":"This webinar was presented by me on February 28th, 2018 as a part of a series of regular biweekly webinars ran by SHARCNET. Visual Studio Code (vscode) is a free and open-source code editor developed by Microsoft for Windows, Linux, and macOS. It includes support for debugging, embedded Git version control, syntax highlighting, intelligent code completion, snippets, and code refactoring. It is also extensible and customizable, so users can install extensions to add new languages, themes, debuggers and change the editor’s keyboard shortcuts, and preferences.\nIn this seminar we focus on one compiled and one scripting language common in advanced research computing projects, namely C/C++ and Python, respectively. We show how to use the same CMake configuration we have developed in the previous talk to edit, version-control, build and debug our C/C++ codebase exactly the same way in vscode on different platforms (only Linux and Windows will be demonstrated). Then we show how to deal effectively with Python codes.\nSome knowledge of Git version control system, CMake build system, and Nix package manager is desirable but not mandatory. To that end, reviewing the following previous seminars before attending this one may be helpful:\nGit and SHARCNET Automating Software Build Process using CMake – Part I Automating Software Build Process using CMake – Part II Exploring a new approach to package management ","date":"February 28, 2018","hero":"/posts/videos/vscode_1/images/p1010356.jpg","permalink":"https://arminms.github.io/posts/videos/vscode_1/","summary":"This webinar was presented by me on February 28th, 2018 as a part of a series of regular biweekly webinars ran by SHARCNET. Visual Studio Code (vscode) is a free and open-source code editor developed by Microsoft for Windows, Linux, and macOS. It includes support for debugging, embedded Git version control, syntax highlighting, intelligent code completion, snippets, and code refactoring. It is also extensible and customizable, so users can install extensions to add new languages, themes, debuggers and change the editor’s keyboard shortcuts, and preferences.","tags":null,"title":"Visual Studio Code – Your Next Coding Companion for Advanced Research Computing"},{"categories":null,"contents":"This webinar was presented by me on April 26th, 2017 as a part of a series of regular biweekly webinars ran by SHARCNET. CMake is a cross-platform, free and open-source build system that allows you automatically build, test, verify, package and deploy software in a compiler-independent manner. In Part I of this seminar we introduced CMake and the first three steps of our tutorial:\nAutomating Software Build Process using CMake – Part I In Part II we will continue with more steps covering other techniques like adding options, correct way of finding Boost library, configuring header files, producing installation packages and so on. It is highly recommended to review the prior talk before attending this one.\n","date":"April 26, 2017","hero":"/posts/videos/cmake_2/images/p1010137.jpg","permalink":"https://arminms.github.io/posts/videos/cmake_2/","summary":"This webinar was presented by me on April 26th, 2017 as a part of a series of regular biweekly webinars ran by SHARCNET. CMake is a cross-platform, free and open-source build system that allows you automatically build, test, verify, package and deploy software in a compiler-independent manner. In Part I of this seminar we introduced CMake and the first three steps of our tutorial:\nAutomating Software Build Process using CMake – Part I In Part II we will continue with more steps covering other techniques like adding options, correct way of finding Boost library, configuring header files, producing installation packages and so on.","tags":null,"title":"Automating Software Build Process using CMake - Part II"},{"categories":null,"contents":"This webinar was presented by me on September 14, 2016 as a part of a series of regular biweekly webinars ran by SHARCNET. CMake is a cross-platform, free and open-source build system that allows you automatically build, test, verify, package and deploy software in a compiler-independent manner. CMake was originally created in 1999 for the Insight Toolkit (ITK) funded by the US National Library of Medicine (NLM) as part of the Visible Human Project and over the past 17 years has become the most popular build tool for C/C++ especially in the field of scientific research (e.g. medical computing, visualization, computer vision and HPC). Some notable applications that use CMake for their build process are: Qt, MySQL, Gromacs, Blender, OpenCV, VTK and ParaView.\nCMake is designed to be used in conjunction with native build environments such as Unix Makefiles, Microsoft Visual Studio and Apple’s Xcode. The build process is controlled by creating one or more configuration files (called CMakeLists.txt files) in each source directory (including subdirectories) that make up a project. Each CMakeLists.txt consists of one or more commands. One of the key features of CMake is the ability to build a directory tree outside the source tree, hence, in case the build directory is removed, the source files remain unaffected. CMake can generate makefiles for many platforms and IDEs including Unix, Windows, Mac OS X, OS/2, MSVC, Unix Makefiles, Ninja, Cygwin, MinGW, NMake, Xcode, CodeBlocks, CodeLite, Eclipse CDT and even Sublime Text.\nThis talk will introduce CMake and go over the basics of using CMake on both user computers and SHARCNET systems to configure and build software. Basic steps of developing a working CMakeLists.txt for a sample software project will also be covered. Some programming experience is helpful but not mandatory.\n","date":"September 14, 2016","hero":"/posts/videos/cmake_1/images/p1010039.jpg","permalink":"https://arminms.github.io/posts/videos/cmake_1/","summary":"This webinar was presented by me on September 14, 2016 as a part of a series of regular biweekly webinars ran by SHARCNET. CMake is a cross-platform, free and open-source build system that allows you automatically build, test, verify, package and deploy software in a compiler-independent manner. CMake was originally created in 1999 for the Insight Toolkit (ITK) funded by the US National Library of Medicine (NLM) as part of the Visible Human Project and over the past 17 years has become the most popular build tool for C/C++ especially in the field of scientific research (e.","tags":null,"title":"Automating Software Build Process using CMake - Part I"},{"categories":null,"contents":"This webinar was presented by me on June 24th, 2015 as a part of a series of regular biweekly webinars ran by SHARCNET. If you need to expose a new HPC service or a brand new scientific methodology to outside community by developing a highly interactive web application but without gaining familiarity with ever-changing technologies such as HTML/XHTML, JavaScript, CSS, AJAX, CGI, DHTML, SVG/VML/Canvas, PHP, etc., this webinar is for you. Wt (pronounced \u0026lsquo;witty\u0026rsquo;) is a freely available (http://www.webtoolkit.eu/) widget-centric C++ library and application server for developing web applications that brings the desktop programming model to web application development. From a programmer\u0026rsquo;s perspective, the Wt API is similar to those offered by libraries such as Qt, GTK, wxWindows, and the like. However, instead of rendering widgets to Windows/X11 windows, Wt incrementally renders the widgets in web browsers. A web application developed with Wt is written in only one compiled language (C++), from which the library generates the necessary HTML/XHTML, JavaScript, CGI, or AJAX code. If available, Wt will maximally use JavaScript and AJAX, but applications developed using Wt will also function correctly when AJAX is not available, or when JavaScript is disabled, reverting to a plain HTML/CGI mechanism for communication between browser and server. Browser-side events such as button clicks, mouse movements, and drag-and-drop events are transparently converted into server-side events using Wt\u0026rsquo;s signal/slot mechanism. Being a native C++ library, web applications developed with Wt typically enjoy greater efficiency and a smaller footprint than Java or Ruby solutions. As such, Wt lends itself to devices where efficiency and footprint matters, like in embedded applications.\nIn this webinar, I will introduce Wt, demonstrate some interesting samples and go over the basics of making an interactive web application. The audience are expected to have some basic programming skills preferably in C++, but no experience in HTML, CSS or JavaScript is necessary.\n","date":"June 24, 2015","hero":"/posts/videos/wt/images/p1010038.jpg","permalink":"https://arminms.github.io/posts/videos/wt/","summary":"This webinar was presented by me on June 24th, 2015 as a part of a series of regular biweekly webinars ran by SHARCNET. If you need to expose a new HPC service or a brand new scientific methodology to outside community by developing a highly interactive web application but without gaining familiarity with ever-changing technologies such as HTML/XHTML, JavaScript, CSS, AJAX, CGI, DHTML, SVG/VML/Canvas, PHP, etc., this webinar is for you.","tags":null,"title":"Programming with Wt - A C++ library for developing stateful and highly interactive web applications"}]